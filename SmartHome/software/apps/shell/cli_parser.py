###############################################################################
#   This program parses the <app_name>_cli.xml file and auto-generates        # 
#   code required for interating with the APP                                 #
#                                                                             #
#   Note : Currently this parser program is very basic, even though the       #
#   .xml files for the clis are actually rich. This parser will generate      #
#   code that doesnt do auto-completion upon tab/any other fancy things       #
#   It will simply use only the cli name field alone from the xml files       #
#   For the user to see all the available commands, he has to type,           #
#   <help> <app-name>                                                         #
###############################################################################


# Simply generate array of constant strings for each app
# When the user types <help> <app-name> simply print the appropriate list of commands

from collections import *
import logging
import xml.etree.ElementTree
import yaml
from datetime import datetime
import sys, getopt
import os
import re

class CliParser(object):
    '''
       This class is used for auto generaing the cli code
    '''
    def __init__(self, confFile): 
        self.confFile = confFile
        with open(confFile, 'r') as ymlfile:            
            self.parser_config = yaml.load(ymlfile, yaml.Loader)

        self.parser_name = self.parser_config['parser']['parser_name']
        self.parser_loc = self.parser_config['parser']['parser_loc']
        self.parser_cli = self.parser_config['parser']['parser_cli']
        self.parser_out = self.parser_config['parser']['parser_out']
        self.parser_files = self.parser_config['parser']['parser_files']

        self.logger_loc = self.parser_config['logger']['log_loc']
        self.logger_type = self.parser_config['logger']['log_type']
        self.logger_lvl = self.parser_config['logger']['log_lvl']
        self.logger_en = self.parser_config['logger']['log_en']       
        self.logLevels = {'dbg_all': logging.DEBUG,
					      'dbg_info': logging.INFO,
                          'dbg_warn' : logging.WARNING, 
                          'dbg_error': logging.ERROR, 
                          'dbg_critical': logging.CRITICAL}
        
        self.initLogger()

    def readCliFile(self, cliFile):
        self.logger.debug("Reading the cli file %s" %(cliFile))
        try:
            cliConf = xml.etree.ElementTree.parse(cliFile).getroot()
        except IOError:
            self.logger.debug("Error: can\'t find file <%s> or error in read data" %(cliFile))
            return
        else:    
            self.logger.debug("Read the conf file <%s> successfully" %(cliFile))

        names = re.split('./', cliFile)
        with open(self.parser_out + names[-1].split('.', 1)[0]+'.c', "w+") as cliGenFile:
            self.writeCliGenFile(cliConf, cliGenFile)


    def writeCliGenFile(self, cliConf, cliGenFile):
        self.logger.debug("Writing to the cli file %s" %(cliGenFile.name))
        cliGenFile.write("/******************************************************************************\n")
        cliGenFile.write("  Note : This is a Auto Generated File. DO NOT EDIT THIS FILE !!!\n")
        cliGenFile.write("  FileName : %s\n" %(cliGenFile.name))
        cliGenFile.write("  Date : %s\n"   %(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
        cliGenFile.write("*******************************************************************************/\n\n")

        # Get the name from the cliConf File
        appName = cliConf.find('app')
        if appName is None:
            # If app name is not present in the cliConf file, use the fileName itself
            cliGenFile.write("const char* %s[] = \n" %(cliGenFile.name.split(".", 1)[0]))
        else:
            cliGenFile.write("const char* %s[] = \n" %(cliConf.find('app').text))

        cliGenFile.write("{\n")
        for _cli in cliConf.findall('cli'):
            cliGenFile.write('  \"' + _cli.get('name') + '\",\n')  
        cliGenFile.write("\n};\n")


    def initLogger(self):
        # Logger support    
        self.logger = logging.getLogger(self.parser_name + 'logger')
        if self.logger_type == 'console':
            hdlr = logging.StreamHandler()
        else:
            hdlr = logging.FileHandler(self.logger_loc + self.parser_name + '.log', 'w')
        formatter = logging.Formatter('%(asctime)s %(levelname)s %(funcName)s [%(lineno)d]: %(message)s')
        hdlr.setFormatter(formatter)
        self.logger.addHandler(hdlr) 
        self.logger.setLevel(self.logLevels.get(self.logger_lvl, logging.ERROR))
        if self.logger_en == 'disable':
            self.logger.setLevel(logging.CRITICAL + 1)

        self.logger.info('Logger initialized successfully')
        self.logger.debug('Logger config: [en = %s, lvl = %s, loc = %s]' 
                %(self.logger_en, self.logger_lvl, self.logger_loc))
        
    
    def parse(self):
        '''
            Get the list of files to be parsed from config file and 
            parse them one by one
        '''
        self.logger.debug("Starting Auto-Generation of CLI files in location %s" %(self.parser_cli))
        for cli_file in self.parser_files:            
            self.readCliFile(self.parser_cli + cli_file)

    def cleanup(self):
        '''
            This function does the cleanup at the end of the program. Once all the compilation is done,
            call this routine to delete all auto generated files
        '''
        for cli_file in self.parser_files:            
            filename = self.parser_out + cli_file.split(".",1)[0]+'.c'

            if os.path.exists(filename):
                os.remove(filename)
            else:
                self.logger.error("Cannot find the file %s" %(filename))

def main(argv):
    # Refer https://stackabuse.com/command-line-arguments-in-python/
    short_options = "hpc"
    long_options = ["help", "parse", "clean"]
    try:
        arguments, values = getopt.getopt(argv, short_options, long_options)
    except getopt.GetoptError:
        print 'cli_parser.py --help'
        sys.exit(2)
       
    for current_argument, current_value in arguments:
        if current_argument in ("-h", "--help"):
            print "Displaying help for the CLI Parser program"
            print "cli-parser.py --parse        This autogenerates the cli files"
            print "cli-parser.py --clean        This cleans autogenerates the cli files"
        elif current_argument in ("-p", "--parse"):
            print "Auto-generating the cli files..."
            cliparser = CliParser('./apps/shell/cli_parser.yaml')
            cliparser.parse()
        elif current_argument in ("-c", "--clean"):
            print "Cleaning the cli workspace..."
            cliparser = CliParser('./apps/shell/cli_parser.yaml')
            cliparser.cleanup()
        

if __name__ == '__main__':
    main(sys.argv[1:])
